# 上下文管理功能说明

## ✨ 功能概述

已为 AI 智能助手添加了**上下文管理**功能，可以让 AI 记住对话历史，实现多轮对话。

## 🎯 主要功能

### 1. 会话上下文管理
- **自动记忆**：每个 WebSocket 会话都会自动维护对话上下文
- **独立会话**：不同用户/浏览器标签页之间的对话相互独立
- **历史保持**：AI 可以记住最近 10 条消息的上下文（可配置）

### 2. 清除对话功能
- 在界面右上角新增了**"清除对话"**按钮
- 点击后会清除当前对话的所有历史记录
- 自动重新连接 WebSocket，创建新的会话

## 🔧 技术实现

### 后端改动（Java）

#### OllamaService.java
```java
// 为每个会话存储 AI 助手实例（包含上下文记忆）
private final Map<String, Assistant> sessionAssistants = new HashMap<>();

// 支持会话 ID 的生成响应方法
public String generateResponse(String sessionId, String userMessage) {
    Assistant assistant = getOrCreateAssistant(sessionId);
    return assistant.chat(userMessage);
}

// 清除会话上下文
public void clearSessionContext(String sessionId) {
    sessionAssistants.remove(sessionId);
}
```

**关键点：**
- 使用 `HashMap` 存储每个会话的 `Assistant` 实例
- 每个 `Assistant` 内部包含 `MessageWindowChatMemory`，保存最近 10 条消息
- 使用 WebSocket Session ID 作为唯一标识符

#### ChatWebSocketHandler.java
```java
// 连接建立时记录会话 ID
public void afterConnectionEstablished(WebSocketSession session) {
    System.out.println("WebSocket 连接已建立，会话ID: " + session.getId());
}

// 处理消息时传入会话 ID
protected void handleTextMessage(WebSocketSession session, TextMessage message) {
    String sessionId = session.getId();
    String aiResponse = ollamaService.generateResponse(sessionId, userInput);
}

// 连接关闭时清除会话上下文
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
    ollamaService.clearSessionContext(session.getId());
}
```

### 前端改动（JavaScript）

#### script.js
```javascript
// 添加清除上下文方法
clearContext() {
    if (confirm('确定要清除对话历史吗？这将开始一个全新的对话。')) {
        // 清除前端显示的消息
        this.messagesContainer.innerHTML = '';
        this.messageHistory = [];
        
        // 重新连接 WebSocket（获取新的 session ID）
        this.socket.close();
        setTimeout(() => {
            this.connectWebSocket();
        }, 100);
    }
}
```

#### index.html
```html
<!-- 新增清除对话按钮 -->
<button id="clearContextBtn" class="clear-context-btn" title="清除对话历史">
    <i class="fas fa-broom"></i>
    <span>清除对话</span>
</button>
```

## 📝 使用示例

### 多轮对话示例

```
用户：鹰潭的天气怎么样？
AI：鹰潭今天天气晴朗，温度 25°C...

用户：那明天呢？
AI：根据之前查询的鹰潭天气... （AI 记住了之前的城市）

用户：和上海比呢？
AI：您刚才问的鹰潭... （AI 可以引用之前的对话）
```

### 清除对话

1. 点击右上角的"清除对话"按钮
2. 确认对话框中点击"确定"
3. 界面会重置，开始新的对话
4. 后端会自动清除旧的上下文记忆

## ⚙️ 配置选项

### 调整记忆长度
在 `OllamaService.java` 中修改：

```java
// 修改这个数字来调整记忆的消息数量
.chatMemory(MessageWindowChatMemory.withMaxMessages(10))
```

### 调整模型温度
控制回答的随机性：

```java
.temperature(0.1)  // 0.0 = 更确定, 1.0 = 更随机
```

## 🎨 UI 改进

### 新增按钮样式
- 半透明背景，现代玻璃态设计
- 悬停时有轻微放大效果
- 与整体 UI 风格一致

### 用户体验
- 清除对话前有确认提示，防止误操作
- 操作后自动显示欢迎消息
- 连接状态实时显示

## 🔒 会话隔离

- **浏览器级别隔离**：每个浏览器标签页都是独立会话
- **自动清理**：WebSocket 连接关闭时，自动清理该会话的内存
- **无状态后端**：所有状态都在内存中，重启服务后自动清空

## 🚀 后续优化建议

1. **持久化存储**：可以将对话历史保存到数据库
2. **用户系统**：关联用户 ID，支持跨设备访问历史
3. **导出功能**：允许用户导出对话历史
4. **更多操作**：删除单条消息、编辑历史消息等

## 📊 性能考虑

- **内存占用**：每个会话约占用 1-5MB 内存（取决于对话长度）
- **会话清理**：连接断开时自动清理，防止内存泄漏
- **并发支持**：使用线程安全的 `HashMap.computeIfAbsent` 方法

## ⚠️ 注意事项

1. **Ollama 服务必须运行**：确保 `localhost:11434` 上的 Ollama 服务已启动
2. **首次启动较慢**：首次调用会加载嵌入模型，可能需要几秒钟
3. **内存限制**：大量并发会话可能占用较多内存，建议监控

## 🎉 功能测试

启动应用后，您可以：

1. 发送消息："你好，我是小明"
2. 继续发送："我刚才说我叫什么？"
3. AI 应该能回答："您说您叫小明"
4. 点击"清除对话"
5. 再次询问："我刚才说我叫什么？"
6. AI 应该回答不知道（因为上下文已清除）

---

**开发日期**：2025-10-29  
**版本**：v1.0



