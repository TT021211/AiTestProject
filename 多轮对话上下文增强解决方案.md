# 多轮对话上下文增强解决方案

## 🎯 问题描述

**原问题**：
```
用户：鹰潭的天气怎么样？
AI：[调用天气API] 鹰潭今天天气晴朗，温度25°C...

用户：适合什么活动？
AI：❌ 抱歉，我无法理解这个消息。
```

**期望效果**：
```
用户：鹰潭的天气怎么样？
AI：[调用天气API] 鹰潭今天天气晴朗，温度25°C...

用户：适合什么活动？
AI：✅ 根据鹰潭今天25°C的晴朗天气，非常适合户外活动！
```

## 💡 解决方案技术栈

### 1. **System Message（系统消息）** ⭐⭐⭐⭐⭐
**最核心的解决方案**

通过 `@SystemMessage` 注解给 AI 提供明确的行为指导：

```java
interface Assistant {
    @SystemMessage({
        "你是一个智能助手，可以帮助用户查询天气、股票等信息。",
        "重要规则：",
        "- 记住整个对话的上下文，包括你之前查询到的所有信息",
        "- 当用户问后续问题时，要基于之前的查询结果来回答",
        "- 如果用户的问题引用了之前的内容，要能理解并给出相关回答"
    })
    String chat(String message);
}
```

**作用**：
- 明确告诉 AI 它的角色和能力
- 指导 AI 如何处理上下文和后续问题
- 提供具体的示例对话

### 2. **增强的 Chat Memory（对话记忆）**

```java
// 从 10 条增加到 20 条消息
MessageWindowChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(20);
```

**作用**：
- 保存更多的对话历史
- 包括用户消息、AI 回复、**工具调用结果**
- 让 AI 能够访问之前查询到的所有数据

### 3. **优化的 Tool Description（工具描述）**

**优化前**：
```java
@Tool("获取指定城市的天气数据。支持模糊城市。")
```

**优化后**：
```java
@Tool("获取指定城市的实时天气数据。参数city为城市名(如鹰潭、北京)，date为日期(可选)。返回温度、天气描述、湿度、风力等详细信息。这些信息可用于回答后续问题，如适合什么活动、穿什么衣服等。")
```

**作用**：
- 明确说明工具返回的数据内容
- 提示 AI 如何使用这些数据回答后续问题
- 帮助 AI 理解工具调用的上下文价值

## 🔧 具体实现细节

### 修改的文件

#### 1. `OllamaService.java`

##### 改动 1：添加 SystemMessage
```java
interface Assistant {
    @SystemMessage({
        "你是一个智能助手，可以帮助用户查询天气、股票等信息。",
        "你拥有以下能力：",
        "1. 查询城市天气信息（通过 get_weather 工具）",
        "2. 查询股票价格信息（通过 get_stock 工具）",
        "",
        "重要规则：",
        "- 记住整个对话的上下文，包括你之前查询到的所有信息",
        "- 当用户问后续问题时（如'适合什么活动'、'那明天呢'），要基于之前的查询结果来回答",
        "- 如果用户的问题引用了之前的内容，要能理解并给出相关回答",
        "- 如果需要更多信息，可以主动询问用户",
        "",
        "示例对话：",
        "用户：鹰潭的天气怎么样？",
        "助手：[调用工具查询] 鹰潭今天天气晴朗，温度25°C...",
        "用户：适合什么活动？",
        "助手：根据鹰潭今天25°C的晴朗天气，非常适合户外活动，比如爬山、骑行、野餐等。",
        "",
        "请始终保持友好、专业，并充分利用对话历史来提供有用的回答。"
    })
    String chat(String message);
}
```

##### 改动 2：增加 ChatMemory 容量
```java
// 从 10 条增加到 20 条
MessageWindowChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(20);
```

#### 2. `WeatherTool.java`

优化工具描述：
```java
@Tool("获取指定城市的实时天气数据。参数city为城市名(如鹰潭、北京)，date为日期(可选)。返回温度、天气描述、湿度、风力等详细信息。这些信息可用于回答后续问题，如适合什么活动、穿什么衣服等。")
```

#### 3. `StockTool.java`

优化工具描述：
```java
@Tool("查询股票的实时价格信息。参数ticker为股票代码(如AAPL)。返回股票代码、当前价格、涨跌幅。可用于回答后续关于该股票的问题。")
```

## 🎓 背后的原理

### LangChain4j 的消息流处理

```
用户消息 → ChatMemory 保存
    ↓
AI 决定调用工具
    ↓
工具返回结果 → ChatMemory 保存（关键！）
    ↓
AI 基于工具结果生成回答 → ChatMemory 保存
    ↓
用户后续问题 → AI 从 ChatMemory 读取之前的所有内容
    ↓
AI 理解上下文并回答
```

### MessageWindowChatMemory 的工作方式

```java
MessageWindowChatMemory.withMaxMessages(20)
```

保存的消息类型：
1. **UserMessage**：用户的输入
2. **AiMessage**：AI 的回复
3. **ToolExecutionRequest**：工具调用请求
4. **ToolExecutionResult**：工具返回的结果 ⭐ **关键**

每种消息都会被保存，AI 可以访问所有这些信息。

### SystemMessage 的作用机制

SystemMessage 会作为**第一条消息**被加入到每次对话中：

```
[SystemMessage] 你是一个智能助手...
[UserMessage] 鹰潭的天气怎么样？
[AiMessage] 让我查询一下...
[ToolExecutionRequest] get_weather(city="鹰潭")
[ToolExecutionResult] {temp: 25, text: "晴"}
[AiMessage] 鹰潭今天天气晴朗，温度25°C
[UserMessage] 适合什么活动？
[AiMessage] 根据25°C的晴朗天气，适合户外活动...
```

## 📊 对比：其他可选方案

### 方案 1：RAG (Retrieval Augmented Generation)
**技术**：向量数据库 + 嵌入模型

```java
// 将工具结果存储到向量数据库
EmbeddingStore<TextSegment> embeddingStore = new InMemoryEmbeddingStore<>();
ContentRetriever retriever = EmbeddingStoreContentRetriever.builder()
    .embeddingStore(embeddingStore)
    .build();
```

**优点**：
- 可以检索更长的历史记录
- 支持语义搜索

**缺点**：
- 实现复杂
- 需要嵌入模型（额外开销）
- 对于短期对话，ChatMemory 更高效

**适用场景**：
- 需要搜索很久之前的对话
- 对话历史非常长（100+ 轮）

### 方案 2：Function Calling with Explicit Context
**技术**：在每次调用时显式传递上下文

```java
public String chat(String message, String previousContext);
```

**优点**：
- 完全可控

**缺点**：
- 需要手动管理上下文
- 代码复杂度高
- LangChain4j 已经提供了更好的方案

### 方案 3：Prompt Engineering Only
**技术**：仅通过优化 Prompt

```java
String enhancedPrompt = "之前我们讨论了：" + previousInfo + "\n现在用户问：" + userMessage;
```

**优点**：
- 最简单

**缺点**：
- 不够智能
- 需要手动拼接上下文
- 容易出错

## ✅ 推荐方案（当前实现）

**System Message + Enhanced ChatMemory**

**为什么这是最佳方案？**

1. ✅ **简单高效**：利用 LangChain4j 内置功能
2. ✅ **自动管理**：ChatMemory 自动保存工具调用结果
3. ✅ **智能理解**：SystemMessage 提供明确指导
4. ✅ **低开销**：不需要额外的嵌入模型或数据库
5. ✅ **可扩展**：可以轻松增加更多工具

## 🎯 测试用例

### 测试 1：天气 + 活动建议
```
用户：鹰潭的天气怎么样？
AI：[调用天气工具] 鹰潭今天天气晴朗，温度25°C，湿度60%

用户：适合什么活动？
AI：✅ 根据鹰潭今天25°C的晴朗天气和适中的湿度，非常适合：
    - 户外运动（跑步、骑行）
    - 野餐和郊游
    - 摄影采风
```

### 测试 2：股票 + 投资建议
```
用户：苹果股票价格多少？
AI：[调用股票工具] AAPL 当前价格 $150.5，涨幅 +2.3%

用户：现在适合买入吗？
AI：✅ 根据 AAPL 当前价格 $150.5 和今日 +2.3% 的涨幅...
```

### 测试 3：多轮引用
```
用户：鹰潭的天气怎么样？
AI：[调用天气工具] 鹰潭今天晴朗，25°C

用户：上海呢？
AI：[调用天气工具] 上海今天多云，22°C

用户：哪个城市更适合户外活动？
AI：✅ 对比鹰潭（25°C，晴朗）和上海（22°C，多云），
    鹰潭的天气更适合户外活动...
```

## 🔍 故障排查

### 问题 1：AI 仍然无法理解后续问题

**可能原因**：
1. ChatMemory 容量太小
2. SystemMessage 不够明确
3. 工具描述不清晰

**解决方法**：
```java
// 1. 增加内存容量
MessageWindowChatMemory.withMaxMessages(30);

// 2. 在 SystemMessage 中添加更多示例

// 3. 在工具描述中明确说明返回数据的用途
```

### 问题 2：AI 混淆不同的查询结果

**可能原因**：
- 对话历史太长，信息重叠

**解决方法**：
```java
// 在重要节点清除上下文
ollamaService.clearSessionContext(sessionId);
```

### 问题 3：回答不够自然

**可能原因**：
- SystemMessage 过于生硬
- 模型温度设置不当

**解决方法**：
```java
// 调整温度（0.0 = 确定性，1.0 = 创造性）
.temperature(0.3)  // 稍微增加一点随机性
```

## 📈 性能优化建议

### 1. 按需清理内存
```java
// 用户长时间不活跃时清理
if (inactiveTime > 30_MINUTES) {
    clearSessionContext(sessionId);
}
```

### 2. 压缩历史消息
```java
// 对于很长的对话，可以总结之前的内容
String summary = summarizePreviousConversation(chatMemory);
```

### 3. 异步工具调用
```java
// 对于耗时的工具调用，使用异步
CompletableFuture<Map<String, Object>> weatherFuture = 
    CompletableFuture.supplyAsync(() -> weatherTool.get_weather(city, date));
```

## 🎊 总结

通过 **System Message + Enhanced ChatMemory + Optimized Tool Descriptions** 三管齐下，我们成功解决了多轮对话中 AI 无法理解后续问题的问题。

**关键要点**：
1. SystemMessage 提供行为指导
2. ChatMemory 自动保存工具调用结果
3. 优化的工具描述帮助 AI 理解数据用途

这个方案简单、高效、易于维护，是处理类似问题的最佳实践！

---

**实现日期**：2025-10-29  
**技术栈**：LangChain4j 0.35.0 + Ollama + Spring Boot 2.7.18



